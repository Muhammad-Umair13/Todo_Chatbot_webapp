["spec.md](spec.md)\n**Purpose**: Consolidate research findings and resolve all technical decisions for the database schema implementation.\n\n## Overview\n\nThis document consolidates research findings for implementing the Phase II Database Schema feature. All technical decisions are documented with rationale and alternatives considered.\n\n---\n\n## Decision 1: Database Schema Design\n\n**Decision**: Use SQLModel table definition matching constitution canonical model.\n\n**Schema**:\n```python\nclass Task(SQLModel, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    user_id: str = Field(index=True)\n    title: str\n    description: str = \"\"\n    completed: bool = False\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\n```\n\n**Rationale**:\n- Matches constitution canonical data model exactly\n- SQLModel provides Pydantic v2 validation and SQLAlchemy ORM\n- Auto-increment id for simple primary key\n- Indexed user_id for fast per-user queries\n- Default values for required fields (description, completed)\n- UTC timestamps using datetime.utcnow\n\n**Alternatives Considered**:\n- UUID primary key: Rejected for Phase II - adds complexity without benefit for scale\n- Composite primary key (id + user_id): Rejected - more complex than needed\n- String primary keys: Rejected - less efficient than integer auto-increment\n\n**Indexing Strategy**:\n1. Primary key index on `id` (automatic)\n2. Index on `user_id` (explicit) - enables fast per-user task queries\n3. Composite index on `(user_id, completed)` - enables filtered task lists (completed/active)\n\n**Validation Rules**:\n- Title: Minimum 1 character (enforced at API layer)\n- Description: Maximum 1000 characters (enforced at database level via VARCHAR(1000))\n- Completed: Defaults to False\n\n---\n\n## Decision 2: Database Connection Management\n\n**Decision**: Use singleton database session pattern with dependency injection.\n\n**Implementation**:\n```python\n# src/database.py\nfrom sqlmodel import SQLModel, create_engine, Session\nfrom typing import AsyncGenerator\n\nDATABASE_URL = os.getenv(\"DATABASE_URL\")\nengine = create_engine(DATABASE_URL)\n\ndef get_session() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        yield session\n```\n\n**Rationale**:\n- FastAPI dependency injection provides automatic session lifecycle management\n- Generator pattern ensures session cleanup after request\n- Singleton engine for connection pooling\n- Aligns with FastAPI best practices\n\n**Alternatives Considered**:\n- Async SQLAlchemy + asyncpg: Rejected - adds complexity, synchronous operations sufficient for Phase II\n- Connection per request (no pooling): Rejected - inefficient for scale\n- Global session: Rejected - not thread-safe, violates stateless principle\n\n---\n\n## Decision 3: User Isolation Enforcement\n\n**Decision**: Enforce ownership at service layer with user_id from JWT.\n\n**Implementation Pattern**:\n```python\n# src/services/task_service.py\nfrom sqlmodel import Session, select\nfrom src.models.task import Task\n\nclass TaskService:\n    @staticmethod\n    def get_tasks(session: Session, user_id: str, completed: bool | None = None):\n        statement = select(Task).where(Task.user_id == user_id)\n        if completed is not None:\n            statement = statement.where(Task.completed == completed)\n        return session.exec(statement).all()\n    \n    @staticmethod\n    def get_task_by_id(session: Session, task_id: int, user_id: str):\n        statement = select(Task).where(Task.id == task_id, Task.user_id == user_id)\n        return session.exec(statement).first()\n    \n    # ... all operations filter by user_id\n```\n\n**Rationale**:\n- Ownership enforced at query level (constitutional requirement)\n- Zero data leakage between users\n- 403 response if resource not owned\n- Service layer pattern separates business logic from API layer\n\n**Alternatives Considered**:\n- Row-level security (RLS) in PostgreSQL: Rejected - adds database complexity, service layer sufficient\n- Middleware enforcement only: Rejected - not granular enough, requires query-level filtering\n- Frontend filtering: Rejected - security risk, client cannot be trusted\n\n---\n\n## Decision 4: API Contract Design\n\n**Decision**: RESTful endpoints with JSON request/response bodies.\n\n**Endpoints**:\n```\nGET    /api/tasks              - List user's tasks (with optional filter)\nPOST   /api/tasks              - Create new task\nGET    /api/tasks/{id}         - Get specific task\nPUT    /api/tasks/{id}         - Update entire task\nPATCH  /api/tasks/{id}         - Partial update\nDELETE /api/tasks/{id}         - Delete task\nPATCH  /api/tasks/{id}/complete - Toggle completion status\n```\n\n**Rationale**:\n- RESTful patterns align with web standards\n- Separate PATCH endpoint for completion is common UX pattern\n- All endpoints protected with JWT (Authorization header)\n- JSON request/response for compatibility with frontend\n\n**Request/Response Models**:\n```python\n# Schemas for API\n\nclass TaskCreate(SQLModel):\n    title: str\n    description: str = \"\"\n    completed: bool = False\n\nclass TaskUpdate(SQLModel):\n    title: str | None = None\n    description: str | None = None\n    completed: bool | None = None\n\nclass TaskRead(SQLModel):\n    id: int\n    user_id: str\n    title: str\n    description: str\n    completed: bool\n    created_at: datetime\n    updated_at: datetime\n```\n\n**Alternatives Considered**:\n- GraphQL: Rejected - overkill for Phase II, REST is sufficient\n- gRPC: Rejected - adds complexity, web frontend needs HTTP\n- PUT for partial updates: Rejected - PATCH is semantically correct for partial updates\n\n---\n\n## Decision 5: JWT Verification & User Extraction\n\n**Decision**: FastAPI dependency for JWT verification with user_id extraction.\n\n**Implementation**:\n```python\n# src/auth/dependencies.py\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom jose import jwt, JWTError\n\nsecurity = HTTPBearer()\nSECRET_KEY = os.getenv(\"JWT_SECRET\")\nALGORITHM = \"HS256\"\n\ndef get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:\n    token = credentials.credentials\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id: str = payload.get(\"sub\")\n        if user_id is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n        return user_id\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n```\n\n**Usage in routers**:\n```python\n@router.get(\"/tasks\")\ndef get_tasks(\n    user_id: str = Depends(get_current_user),\n    completed: bool | None = None,\n    session: Session = Depends(get_session)\n):\n    return task_service.get_tasks(session, user_id, completed)\n```\n\n**Rationale**:\n- FastAPI dependencies provide clean, reusable auth logic\n- HTTPBearer handles Authorization header parsing\n- JWT verification happens before business logic\n- Extracts user_id for use in service layer\n\n**Alternatives Considered**:\n- Middleware: Rejected - dependencies provide better per-endpoint control\n- Session-based: Rejected - violates stateless principle (constitution)\n- Custom header: Rejected - Authorization: Bearer is standard\n\n---\n\n## Decision 6: Error Handling Strategy\n\n**Decision**: Structured JSON errors with appropriate HTTP status codes.\n\n**Error Response Format**:\n```json\n{\n  \"detail\": \"User-friendly error message\",\n  \"error_code\": \"SPECIFIC_ERROR_CODE\"\n}\n```\n\n**Status Codes**:\n- `400` - Validation error (empty title, description too long)\n- `401` - Invalid JWT or missing authentication\n- `403` - Resource not owned by user\n- `404` - Task not found (or not owned)\n- `422` - Unprocessable entity (Pydantic validation)\n- `500` - Internal server error (logged, user-friendly message)\n\n**Implementation**:\n```python\n# src/core/config.py\nclass HTTPError(Exception):\n    def __init__(self, status_code: int, detail: str):\n        self.status_code = status_code\n        self.detail = detail\n\n# In routers\nraise HTTPException(status_code=403, detail=\"Task not found\")\n```\n\n**Rationale**:\n- Structured errors enable frontend handling\n- Appropriate status codes follow HTTP semantics\n- No stack traces in production (security requirement)\n- User-friendly messages (constitution requirement)\n\n---\n\n## Decision 7: Database Migration Strategy\n\n**Decision**: Alembic for schema versioning and migrations.\n\n**Initial Migration**:\n```python\n# alembic/versions/001_initial.py\ndef upgrade():\n    op.create_table(\n        'task',\n        sa.Column('id', sa.Integer(), primary_key=True),\n        sa.Column('user_id', sa.String(), nullable=False),\n        sa.Column('title', sa.String(), nullable=False),\n        sa.Column('description', sa.String(length=1000)),\n        sa.Column('completed', sa.Boolean(), nullable=False),\n        sa.Column('created_at', sa.DateTime(timezone=True)),\n        sa.Column('updated_at', sa.DateTime(timezone=True)),\n        sa.Index('ix_task_user_id', 'user_id'),\n        sa.Index('ix_task_user_id_completed', 'user_id', 'completed')\n    )\n\ndef downgrade():\n    op.drop_table('task')\n```\n\n**Rationale**:\n- Alembic is Python-native and integrates with SQLModel\n- Version control for schema changes\n- Reversible migrations\n- No destructive changes in Phase II (specification requirement)\n\n**Migration Commands**:\n```bash\nalembic revision --autogenerate -m \"Initial schema\"\nalembic upgrade head\nalembic downgrade -1\n```\n\n---\n\n## Decision 8: Testing Strategy\n\n**Decision**: pytest with fixtures for database and authentication.\n\n**Test Structure**:\n```python\n# tests/conftest.py\nimport pytest\nfrom sqlmodel import create_engine, Session\nfrom sqlmodel.pool import StaticPool\nfrom src.models.task import Task\n\n@pytest.fixture\ndef test_session():\n    engine = create_engine(\n        \"sqlite:///:memory:\",\n        connect_args={\"check_same_thread\": False},\n        poolclass=StaticPool,\n    )\n    SQLModel.metadata.create_all(engine)\n    with Session(engine) as session:\n        yield session\n\n@pytest.fixture\ndef mock_user_id():\n    return \"test-user-123\"\n```\n\n**Test Coverage Required**:\n- **Positive tests**: Successful CRUD operations\n- **Negative tests**: Invalid input, missing fields\n- **Ownership tests**: User cannot access another user's tasks\n- **Authentication tests**: 401 without JWT, 403 without ownership\n- **Database persistence tests**: Data survives session restart\n\n**Rationale**:\n- pytest is Python standard and integrates well with FastAPI\n- In-memory SQLite for fast tests (constitution requires pytest)\n- Fixtures provide reusable test setup\n- Comprehensive test coverage per constitution requirements\n\n---\n\n## Decision 9: Environment Configuration\n\n**Decision**: Environment variables for all secrets and configuration.\n\n**Required Environment Variables**:\n```bash\nDATABASE_URL=postgresql://user:pass@host/db\nJWT_SECRET=your-secret-key\nCORS_ORIGINS=http://localhost:3000,https://yourapp.com\n```\n\n**Implementation**:\n```python\n# src/core/config.py\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    DATABASE_URL: str\n    JWT_SECRET: str\n    CORS_ORIGINS: str\n\n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()\n```\n\n**Rationale**:\n- No secrets in code (constitution requirement)\n- Easy environment-specific configuration\n- Pydantic settings provides validation\n- .env file for local development\n\n---\n\n## Decision 10: Frontend API Client\n\n**Decision**: Centralized TypeScript API client with JWT attachment.\n\n**Implementation**:\n```typescript\n// frontend/src/lib/api-client.ts\nclass ApiClient {\n  private baseUrl: string;\n\n  constructor() {\n    this.baseUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';\n  }\n\n  private async request<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<T> {\n    const token = await getToken(); // Better Auth\n    const headers: HeadersInit = {\n      'Content-Type': 'application/json',\n      ...(token && { 'Authorization': `Bearer ${token}` }),\n      ...options.headers,\n    };\n\n    const response = await fetch(`${this.baseUrl}${endpoint}`, {\n      ...options,\n      headers,\n    });\n\n    if (!response.ok) {\n      throw new Error(`API error: ${response.statusText}`);\n    }\n\n    return response.json();\n  }\n\n  // ... CRUD methods\n}\n```\n\n**Task Service**:\n```typescript\n// frontend/src/services/task-service.ts\nclass TaskService {\n  async getTasks(completed?: boolean): Promise<Task[]> {\n    const params = completed ? `?completed=${completed}` : '';\n    return apiClient.get(`/api/tasks${params}`);\n  }\n\n  async createTask(task: TaskCreate): Promise<Task> {\n    return apiClient.post('/api/tasks', task);\n  }\n \n  // ... other methods\n}\n```\n\n**Rationale**:\n- Centralized API client avoids code duplication\n- JWT automatically attached from Better Auth\n- Type-safe with TypeScript\n- Handles errors consistently\n- No localStorage usage (constitution requirement)\n\n---\n\n## Decision 11: Performance Considerations\n\n**Decision**: Optimize for sub-500ms query performance.\n\n**Optimizations**:\n1. Database indexes on user_id and (user_id, completed)\n2. Connection pooling via SQLAlchemy engine\n3. Query result limiting (pagination for large task lists)\n4. Efficient WHERE clause filtering\n\n**Query Example**:\n```python\n# Efficient: uses indexes\nselect(Task).where(Task.user_id == user_id, Task.completed == False)\n\n# Avoid: function calls prevent index usage\nselect(Task).where(func.lower(Task.user_id) == user_id.lower())\n```\n\n**Rationale**:\n- Meets success criteria SC-003 (<500ms for 1,000 tasks)\n- Indexes enable O(log n) lookups\n- Connection pooling reduces connection overhead\n- Pagination prevents large result sets\n\n---\n\n## Decision 12: Phase III Forward Compatibility\n\n**Decision**: Service layer pattern with stateless operations.\n\n**Design Principles**:\n1. All task operations are service methods\n2. Services accept session and user_id as parameters\n3. No session-level state maintained\n4. Clear separation of concerns (service, router, model)\n\n**Example**:\n```python\n# Service layer - can be called from API, CLI, or MCP tools\nclass TaskService:\n    @staticmethod\n    def create_task(session: Session, task_data: TaskCreate, user_id: str) -> Task:\n        # Stateless operation\n        task = Task.model_validate(task_data)\n        task.user_id = user_id\n        session.add(task)\n        session.commit()\n        session.refresh(task)\n        return task\n```\n\n**Rationale**:\n- Enables Phase III MCP tools to use same service layer\n- Stateless API supports scaling\n- No architectural rewrite needed for Phase III\n- Clear interface for programmatic access\n\n---\n\n## Summary of Resolved Decisions\n\nAll technical decisions have been resolved. No NEEDS CLARIFICATION markers remain. The implementation plan can proceed to Phase 1 (Design & Contracts).\n\n### Key Takeaways\n\n1. **Database**: SQLModel with Neon PostgreSQL, indexed user_id filtering\n2. **Architecture**: Service layer pattern, stateless REST API\n3. **Authentication**: JWT via Better Auth, user_id enforced at service level\n4. **Testing**: pytest with in-memory SQLite, comprehensive coverage\n5. **Frontend**: Centralized TypeScript client, no localStorage\n6. **Performance**: Sub-500ms via indexing and connection pooling\n7. **Forward Compatibility**: Service layer enables Phase III MCP tools\n8. **Security**: Zero data leakage, structured errors, no secrets in code\n\n**Status**: \u2705 Ready for Phase 1 - Design & Contracts"]